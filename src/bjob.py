"""
Handle job submitting to LSF
"""


# Dependencies
import subprocess
import time
import re


class Bjob(object):

    def __init__(self, id=None, status=None, out_path='/dev/null', err_path='/dev/null'):
        self.id = id
        self.curr_status = status
        self.out_path = out_path
        self.err_path = err_path

    def get_status(self):
        """Retrieve job status
        Check status onnly if it is RUN or PEND, otherwise, returns the already
        set status

        Return
        (str)   Job status, which can be 'RUN', 'PEND', 'DONE', 'EXIT'
        """
        # If not running, return current status
        if self.curr_status not in set(['RUN', 'PEND']):
            return self.curr_status
        # Otherwise, retrieve status using bjobs
        self.curr_status = self.__class__.status(self.id)
        # Return retrieved status
        return self.curr_status

    def is_running(self):
        """Define if current job is running

        Return
        (bool)  Whether job is running or not
        """
        # Get current job status
        status = self.get_status()
        # Return bool if status is running or pending
        return (status in set(['RUN', 'PEND']))

    @classmethod
    def run(cls, args, out_path='/dev/null', err_path='/dev/null', **kwargs):
        """Run a job
        Run a job by submitting it to LSF scheduler: this method takes as input
        subprocess arguments and feeds them to bsub command, along with other
        optional arguments

        Args
        args (list):    List of arguments, such as subprecess args
        out_path (str): Path to output log file
        err_path (str): Path to error log file

        Return
        (Bjob):         Instance of generated bjob
        """
        # Reformat code to make it run on LSF
        args = ['bsub', '-o', out_path, '-e', err_path] + args
        # Run command on LSF
        out = subprocess.run(
            capture_output=True,  # Retain output
            encoding='utf-8',  # Encoding
            args=args  # bsub arguments
        )
        # # Debug
        # print('bjobs (submit):', out)
        # Retrieve job id
        id = cls.id_from_string(out.stdout)
        # Return retrieved Bjob instance with give job id
        return cls(id=id, status='RUN', out_path=out_path, err_path=err_path)

    @classmethod
    def check(cls, bjobs, delay=30):
        """Check list of jobs
        Checks the given list of jobs (or a single one) until all are finished

        Args
        bjobs (list):   List of bjobs whose status must be checked
        delay (int):    Number of seconds between a check and the other
        """
        # Start looping
        while True:
            # Get number of jobs
            n = len(bjobs)
            # Check status for every job
            are_running = list(map(lambda bjob: bjob.is_running(), bjobs))
            # Count running jobs
            num_running = sum(are_running)
            # Debug
            print('There are {} jobs which are still running:\n{}'.format(
                # Number of running jobs
                num_running,
                # Actual ids of running jobs
                ', '.join([bjobs[i].id for i in range(n) if are_running[i]])
            ))
            # Check if at least one process is still running
            if not num_running:
                # Debug
                print('No more running jobs')
                # Terminate looping
                break
            # Wait for given delay
            time.sleep(delay)

    @classmethod
    def status(cls, job_id):
        # Retrieve command output
        out = subprocess.run(
            capture_output=True,
            encoding='utf-8',
            args=['bjobs', '-noheader', '-a', job_id]
        )
        # # Debug
        # print('bjobs (status):', out)
        # Match bjobs row format
        match = re.search(r'^(\S+)\s+(\S+)\s+(\S+)\s+', out.stdout)
        # Case row format does not match
        if not match:
            # Don't know if bjob is done or not, but for sure it is exited
            return 'EXIT'
        # Get job id, user name and job status
        found_job_id = match.group(1)
        found_user_name = match.group(2)
        found_job_status = match.group(3)
        # Check status value
        if found_job_status not in set(['RUN', 'PEND', 'DONE', 'EXIT']):
            raise ValueError('Got an invalid job status')
        # Return retrieved status
        return found_job_status

    @classmethod
    def kill(cls, job_id):
        raise NotImplementedError

    @classmethod
    def id_from_string(cls, in_string):
        """ Retrieve process id from verbose output

        Args
        in_string (str):    Input string, generated by submitting a job to lsf

        Return
        (str):              Job id, as string (avoids cutting leading zeroes)
        """
        # Retrieve job id
        job_id = str(re.search(r'^Job \<([\d]+)\>', in_string).group(1))
        # # Debug
        # print('Retrieved job id: {}'.format(job_id))
        # Return retrieved job id
        return job_id
