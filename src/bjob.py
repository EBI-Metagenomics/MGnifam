"""
Handle job submitting to LSF
"""


# Dependencies
import subprocess
import re


class Bjob(object):

    def __init__(self, id=None, status=None, out_path='/dev/null', err_path='/dev/null'):
        self.id = id
        self.status = status
        self.out_path = out_path
        self.err_path = err_path

    def get_status(self):
        """Retrieve job status

        Return
        (str)   Job status, which can be 'RUN', 'PEND', 'DONE', 'EXIT'
        """
        # Return retrieved status
        return self.__class__.status(self.id)

    @classmethod
    def run(cls, args, out_path='/dev/null', err_path='/dev/null', **kwargs):
        """Run a job
        Run a job by submitting it to LSF scheduler: this method takes as input
        subprocess arguments and feeds them to bsub command, along with other
        optional arguments

        Args
        args (list):    List of arguments, such as subprecess args
        out_path (str): Path to output log file
        err_path (str): Path to error log file

        Return
        (Bjob):         Instance of generated bjob
        """
        # Reformat code to make it run on LSF
        args = ['bsub', '-o', out_path, '-e', err_path] + args
        # Run command on LSF
        out = subprocess.run(
            capture_output=True,  # Retain output
            encoding='utf-8',  # Encoding
            check=True,  # Check execution
            args=args  # bsub arguments
        )
        # Debug
        print('bsub:', out)
        # Retrieve job id
        id = cls.id_from_string(out.stdout)
        # Return retrieved Bjob instance with give job id
        return cls(id=id, status='RUN', out_path=out_path, err_path=err_path)

    @classmethod
    def status(cls, job_id):
        # Retrieve command output
        out = subprocess.run(
            capture_output=True,
            encoding='utf-8',
            check=True,
            args=['bjobs', '-noheader', '-a', job_id]
        )
        # Debug
        print('bjobs (status):', out)
        # Split output
        out = re.sub(r'[ \t]+', ' ', out.stdout).split(' ')
        # Retrieve status as string
        status = str(out[2])
        # Check status value
        if status not in set(['RUN', 'PEND', 'DONE', 'EXIT']):
            raise ValueError('Unable to parse status command')
        # Return retrieved status
        return status

    @classmethod
    def kill(cls, job_id):
        raise NotImplementedError

    @classmethod
    def id_from_string(cls, in_string):
        """ Retrieve process id from verbose output

        Args
        in_string (str):    Input string, generated by submitting a job to lsf

        Return
        (str):              Job id, as string (avoids cutting leading zeroes)
        """
        return str(re.search(r'^Job \<([\d]+)\>', in_string).group(1))
